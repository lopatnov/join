{"version":3,"file":"join.min.js","sources":["../src/join.ts"],"sourcesContent":["/**\n * Join Types\n */\nexport enum JoinTypes {\n  none = 0b0000,\n  left = 0b1000,\n  right = 0b0001,\n  innerLeft = 0b0100,\n  innerRight = 0b0010,\n  innerJoin = none | innerLeft | innerRight | none,\n  leftJoin =  left | innerLeft | innerRight | none,\n  rightJoin = none | innerLeft | innerRight | right,\n  fullJoin =  left | innerLeft | innerRight | right,\n  expand =    left | none      | innerRight | right\n}\n\nfunction getPartNames(left: any, right: any) {\n  let namesLeft = Object.getOwnPropertyNames(left);\n  let namesRight = Object.getOwnPropertyNames(right);\n  let namesMid = namesLeft.filter(x => namesRight.indexOf(x) > -1);\n  namesLeft = namesLeft.filter(x => namesMid.indexOf(x) < 0);\n  namesRight = namesRight.filter(x => namesMid.indexOf(x) < 0);\n  return {\n    left: namesLeft,\n    middle: namesMid,\n    right: namesRight\n  };\n}\n\nfunction clearNames(obj: any, names: string[]) {\n  for (let i = 0; i < names.length; i++) {\n    delete obj[names[i]];\n  }\n}\n\nfunction attach(toObj: any, attachment: any, names: string[]) {\n  if (toObj === attachment) return;\n\n  for (let i = 0; i < names.length; i++) {\n    let descriptor = Object.getOwnPropertyDescriptor(attachment, names[i]);\n    Object.defineProperty(toObj, names[i], descriptor as PropertyDescriptor);\n  }\n}\n\nfunction isFunction(obj: any) {\n  // Support: Chrome <=57, Firefox <=52\n  // In some browsers, typeof returns \"function\" for HTML <object> elements\n  // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n  // We don't want to classify *any* DOM node as a function.\n  return typeof obj === \"function\" && typeof obj.nodeType !== \"number\";\n}\n\nfunction isPlainObject(obj: any) {\n  var proto, Ctor;\n  let toString = Object.prototype.toString;\n  let getProto = Object.getPrototypeOf;\n  let hasOwn = Object.prototype.hasOwnProperty;\n  var fnToString = hasOwn.toString;\n  var ObjectFunctionString = fnToString.call(Object);\n\n  // Detect obvious negatives\n  // Use toString instead of type to catch host objects\n  if (!obj || toString.call(obj) !== \"[object Object]\") {\n    return false;\n  }\n\n  proto = getProto(obj);\n\n  // Objects with no prototype (e.g., `Object.create( null )`) are plain\n  if (!proto) {\n    return true;\n  }\n\n  // Objects with prototype are plain iff they were constructed by a global Object function\n  Ctor = hasOwn.call(proto, \"constructor\") && proto.constructor;\n  return (\n    typeof Ctor === \"function\" && fnToString.call(Ctor) === ObjectFunctionString\n  );\n}\n\nfunction extend(...args: any[]) {\n  var options,\n    name,\n    src,\n    copy,\n    copyIsArray,\n    clone,\n    target = arguments[0] || {},\n    i = 1,\n    length = arguments.length,\n    deep = false;\n\n  // Handle a deep copy situation\n  if (typeof target === \"boolean\") {\n    deep = target;\n\n    // Skip the boolean and the target\n    target = arguments[i] || {};\n    i++;\n  }\n\n  // Handle case when target is a string or something (possible in deep copy)\n  if (typeof target !== \"object\" && !isFunction(target)) {\n    target = {};\n  }\n\n  // Extend itself if only one argument is passed\n  if (i === length) {\n    target = {};\n    i--;\n  }\n\n  for (; i < length; i++) {\n    // Only deal with non-null/undefined values\n    if ((options = arguments[i]) != null) {\n      // Extend the base object\n      for (name in options) {\n        copy = options[name];\n\n        // Prevent Object.prototype pollution\n        // Prevent never-ending loop\n        if (name === \"__proto__\" || target === copy) {\n          continue;\n        }\n\n        // Recurse if we're merging plain objects or arrays\n        if (\n          deep &&\n          copy &&\n          (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))\n        ) {\n          src = target[name];\n\n          // Ensure proper type for the source value\n          if (copyIsArray && !Array.isArray(src)) {\n            clone = [];\n          } else if (!copyIsArray && !isPlainObject(src)) {\n            clone = {};\n          } else {\n            clone = src;\n          }\n          copyIsArray = false;\n\n          // Never move original objects, clone them\n          target[name] = extend(deep, clone, copy);\n\n          // Don't bring in undefined values\n        } else if (copy !== undefined) {\n          target[name] = copy;\n        }\n      }\n    }\n  }\n\n  // Return the modified object\n  return target;\n}\n\nfunction mergeObjects(left: any, right: any, names: string[]) {\n  if (left === right) return;\n  for (let i = 0; i < names.length; i++) {\n    if (\n      right[names[i]] === null ||\n      [\n        \"string\",\n        \"boolean\",\n        \"null\",\n        \"undefined\",\n        \"symbol\",\n        \"number\",\n        \"bigint\",\n        \"regexp\"\n      ].indexOf((typeof right[names[i]]).toLowerCase()) > -1\n    ) {\n      let descriptor = Object.getOwnPropertyDescriptor(right, names[i]);\n      Object.defineProperty(left, names[i], descriptor as PropertyDescriptor);\n    } else {\n      left[names[i]] = extend(true, left[names[i]], right[names[i]]);\n    }\n  }\n}\n\nfunction joinSource<TContext, TJoinObject>(\n  this: TContext,\n  withObject: TJoinObject,\n  joinType: JoinTypes = JoinTypes.expand\n): TContext & TJoinObject {\n  if ((joinType | 0b1111) <= 0)\n    throw new Error(\"Invalid join type. Please select join type\");\n\n  if (joinType === (JoinTypes.left | JoinTypes.innerLeft)) {\n    return this as any;\n  }\n\n  let names = getPartNames(this, withObject);\n\n  //merge\n  switch (joinType & JoinTypes.innerJoin) {\n    case JoinTypes.none:\n      clearNames(this, names.middle);\n      break;\n    case JoinTypes.innerLeft:\n      break;\n    case JoinTypes.innerRight:\n      attach(this, withObject, names.middle);\n      break;\n    case JoinTypes.innerJoin:\n      mergeObjects(this, withObject, names.middle);\n      break;\n  }\n\n  //left\n  if ((joinType & JoinTypes.left) !== JoinTypes.left) {\n    clearNames(this, names.left);\n  }\n\n  //right\n  if ((joinType & JoinTypes.right) === JoinTypes.right) {\n    attach(this, withObject, names.right);\n  }\n\n  return this as any;\n}\n\nexport function join(joinType: JoinTypes = JoinTypes.expand) {\n  if (!joinType) {\n    throw new Error('Unknown join type');\n  }\n  return function<TContext>(context: TContext) {\n    return function<TJoinObject>(joinObject: TJoinObject): TContext & TJoinObject {\n      return joinSource.call(context, joinObject, joinType) as TContext & TJoinObject;\n    }\n  }\n}"],"names":["JoinTypes","getPartNames","left","right","namesLeft","Object","getOwnPropertyNames","namesRight","namesMid","filter","x","indexOf","middle","clearNames","obj","names","i","length","attach","toObj","attachment","descriptor","getOwnPropertyDescriptor","defineProperty","isFunction","nodeType","isPlainObject","proto","Ctor","toString","prototype","getProto","getPrototypeOf","hasOwn","hasOwnProperty","fnToString","ObjectFunctionString","call","constructor","extend","_i","args","options","name","src","copy","copyIsArray","clone","target","arguments","deep","Array","isArray","undefined","mergeObjects","toLowerCase","joinSource","withObject","joinType","expand","Error","innerLeft","this","innerJoin","none","innerRight","join","context","joinObject"],"mappings":"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"}